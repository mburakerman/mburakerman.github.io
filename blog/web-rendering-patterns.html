<!DOCTYPE html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#3C4556" />

  <link rel="icon" type="image/png" href="/img/favicon.png" />

  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=Montserrat:300,400,500,600&display=swap"
  />

  <title>Web Rendering Patterns</title>

  <meta name="title" content="Web Rendering Patterns" />
  <meta name="description" content="10 Web Rendering Patterns in a nutshell" />

  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website" />
  <meta
    property="og:url"
    content="https://mburakerman.github.io/blog/web-rendering-patterns"
  />
  <meta property="og:title" content="Web Rendering Patterns" />
  <meta
    property="og:description"
    content="10 Web Rendering Patterns in a nutshell"
  />
  <meta property="og:image" content="" />

  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image" />
  <meta
    property="twitter:url"
    content="https://mburakerman.github.io/blog/web-rendering-patterns"
  />
  <meta property="twitter:title" content="Web Rendering Patterns" />
  <meta
    property="twitter:description"
    content="10 Web Rendering Patterns in a nutshell"
  />
  <meta property="twitter:image" content="" />

  <link rel="stylesheet" href="/css/main.css?v=2.26" />
  <style type="text/css">
    a {
      color: #fff;
      text-decoration: none;
      border-bottom: 1px solid;
    }
    h1 {
      font-size: 26px;
      margin-bottom: 15px;
    }
    time {
      font-size: smaller;
      opacity: 0.9;
    }
    .blog-article {
      width: 100%;
      max-width: 768px;
    }
    .blog-article p {
      font-size: 16px;
    }
    .blog-article h2 {
      font-size: 20px;
      color: #fff;
      margin-bottom: 10px;
    }
    .blog-article ul {
      padding-left: 20px;
    }
    .blog-article ul li {
      font-size: 16px;
      list-style-type: disc;
      margin-bottom: 10px;
    }
    .blog-article img {
      height: 30px;
      max-width: 60px;
      object-fit: contain;
      position: relative;
      top: 8px;
    }
    .blog-article img:first-child {
      margin-left: 15px;
    }
  </style>
</head>

<body>
  <article class="blog-article">
    <h1 id="web-rendering-patterns">Web Rendering Patterns</h1>
    <p><time>🗓️ 13 Jan 2023</time></p>
    <p>
      <br />
    </p>
    <p>
      We find ourselves in an era where a new JavaScript framework was born,
      bringing exciting possibilities to the web development landscape.
    </p>
    <p>
      However, its complexity can be overwhelming, especially for those new to
      the field.
    </p>
    <p>
      In order to ease this challenge, this blog post simplifies 10 Web
      Rendering Patterns for your convenience.
    </p>

    <br />
    <br />

    <h2 id="1-static">
      1. Static
      <img src="/img/web-rendering-patterns/html-5.svg" alt="HTML 5" />
    </h2>
    <ul>
      <li>Upload your static files (like html) on server and it’s done</li>
      <li>
        Some sitatic site generators like
        <a
          href="https://jekyllrb.com/"
          target="_blank"
          rel="noopener noreferrer"
          >Jekyll</a
        >
        can convert markdown into sitatic files so you don’t need you write html
        code
      </li>
      <li>😔 Not good for websites that frequently update their content</li>
    </ul>

    <br />
    <br />

    <h2 id="2-mpa-multi-page-application">
      2. MPA (Multi Page Application)
      <img src="/img/web-rendering-patterns/laravel.png" alt="Laravel" />
    </h2>
    <ul>
      <li>
        (MPA) is a type of web application where each web page corresponds to a
        different URL
      </li>
      <li>
        Whenever a user navigates to different parts of the application, the
        browser sends a request to the server for a new html, which is then
        rendered in the browser
      </li>
      <li>Each page has its own html file</li>
      <li>
        😔 Whenever user navigates new page, browser have to request new html,
        css, js from the server
      </li>
      <li>😔 Less seamless UX</li>
    </ul>

    <br />
    <br />

    <h2 id="3-spa-single-page-application-">
      3. SPA (Single Page Application)
      <img src="/img/web-rendering-patterns/react.png" alt="React" />
      <img src="/img/web-rendering-patterns/vue.png" alt="Vue" />
    </h2>
    <ul>
      <li>
        Unlike MPA, SPA loads single html page and all UI changes are made using
        JavaScript
      </li>
      <li>
        😔 Since all UI updates requires javascript, initial page loads can be
        very slow
      </li>
      <li>😔 Not search engine friendly (yes... still 🤦🏼‍♂️)</li>
    </ul>

    <br />
    <br />

    <h2 id="4-ssr-server-side-rendering-">
      4. SSR (Server Side Rendering)
      <img src="/img/web-rendering-patterns/next.png" alt="Next" />
      <img src="/img/web-rendering-patterns/nuxt.png" alt="Nuxt.png" />
    </h2>
    <ul>
      <li>
        Render html on the server and then after initial page load hydrate
        client side javascript to make web page intractive
      </li>
      <li>SSR is like MPA + SPA</li>
      <li>😔 Server cost</li>
    </ul>

    <br />
    <br />

    <h2 id="5-streaming-ssr">
      5. Streaming SSR
      <img src="/img/web-rendering-patterns/next.png" alt="Next" />
    </h2>
    <ul>
      <li>
        Allows us to send components down to the client as soon as they’ve been
        generated
      </li>
      <li>
        With regular SSR, the user has to wait for the entire html to be
        generated on the server before it gets send down to the client
      </li>
      <li>
        However, with streaming SSR, the components get streamed down as soon as
        they’re ready. So UI became interactive faster
      </li>
      <li>
        😔 May result in more network traffic compared to traditional server
        rendering, as the browser receives html in chunks instead of a single
        response
      </li>
    </ul>

    <br />
    <br />

    <h2 id="6-ssg-static-site-generation">
      6. SSG (Static Site Generation)
      <img src="/img/web-rendering-patterns/gatsby.png" alt="Gatsby" />
    </h2>
    <ul>
      <li>
        Pre-built your html, css and javascript files and serve them as static
        files
      </li>
      <li>Like SSR, hydration occur after initial page load</li>
      <li>
        Great choice for where majority of website is static. <br />
        Imagine an e-commerce website: while the product page is dynamic, we can
        pre-render rest of the static pages on server and use external api for
        product page to load dynamic data
      </li>
      <li>😔 Have to deptoy whenever your static data changes</li>
    </ul>

    <br />
    <br />

    <h2 id="7-isr-incremental-static-regeneration">
      7. ISR (Incremental Static Regeneration)
      <img src="/img/web-rendering-patterns/next.png" alt="Next" />
    </h2>
    <ul>
      <li>
        Allows you to create or update content without redeploying your site
      </li>
      <li>
        It’s like improved version of SSG because we have to deploy SSG app even
        we have small change in the app
      </li>
      <li>
        With ISR, the SSG will only regenerate the specific pages or sections of
        the site that have been updated, rather than regenerating the entire
        site. E.g. If revalidation is set 10 seconds, the page will be
        regenerated after the first request
      </li>
      <li>😔 There is no guarantee that user sees the latest version</li>
    </ul>

    <br />
    <br />

    <h2 id="8-partial-hydration-">
      8. Partial Hydration
      <img src="/img/web-rendering-patterns/vite.svg" alt="Vite" />
      <img src="/img/web-rendering-patterns/next.png" alt="Next" />
    </h2>
    <ul>
      <li>
        Hydrate selected part of the website instead of all using code splitting
      </li>
      <li>
        E.g. we can leave footer static until user scrolls to bottom and when
        user reaches, we can hydrate it
      </li>
      <li>😔 Can make testing harder and cause content shifting</li>
    </ul>

    <br />
    <br />

    <h2 id="9-islands">
      9. Islands <img src="/img/web-rendering-patterns/astro.svg" alt="Astro" />
    </h2>
    <ul>
      <li>
        General idea of an
        <a
          href="https://docs.astro.build/en/concepts/islands/"
          target="_blank"
          rel="noopener noreferrer"
          >islands architecture</a
        >
        is: render html pages on the server, and inject placeholders or slots
        around highly dynamic regions
      </li>
      <li>
        There are independent “islands” to load and hydrate the component in
        isolation rather than whole application
      </li>
      <li>
        Looks like better version of code-splitting and may seem similar to
        <a
          href="https://micro-frontends.org/"
          target="_blank"
          rel="noopener noreferrer"
          >micro-frontends</a
        >
      </li>
      <li>
        Astro generates every website with zero client-side javascript, by
        default. If your component/page has no javascript interactivity, Astro
        don’t ship javascript to the client at all even you build your app with
        a javascript library like React
      </li>
      <li>
        😔 Relies on each island being independent, which can make it harder to
        share functionality between islands
      </li>
    </ul>

    <br />
    <br />

    <h2 id="10-resumability">
      10. Resumability
      <img src="/img/web-rendering-patterns/qwik.png" alt="Qwik.png" />
    </h2>
    <ul>
      <li>
        Resumability is about pausing execution in the server and resuming
        execution in the client without having to replay and download all of the
        application logic
      </li>
      <li>
        All website serialized into html (data, event listeners…). Javascript
        code broken into tiny chunks and initial page load is always static
        html. There is no hydration
      </li>
      <li>Everything is lazy loaded</li>
      <li>
        So, how do these multiple chunks of javascript files determine when to
        execute? They know it because of serialization
      </li>
      <li>
        Javascript is not shipped until the user interacts with it. Take a React
        Counter button as an example. Javascript for the button is not loaded
        until the user clicks it
      </li>
    </ul>
  </article>
</body>
